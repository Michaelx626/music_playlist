{"version":3,"file":"profile.js","sourceRoot":"","sources":["../../../../src/testing/internal/profile/profile.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from \"react\";\n\nimport { TextEncoder, TextDecoder } from \"util\";\n\nglobal.TextEncoder ??= TextEncoder;\n// @ts-ignore\nglobal.TextDecoder ??= TextDecoder;\nimport type { Render, BaseRender } from \"./Render.js\";\nimport { RenderInstance } from \"./Render.js\";\nimport { applyStackTrace, captureStackTrace } from \"./traces.js\";\n\ntype ValidSnapshot = void | (object & { /* not a function */ call?: never });\n\n/** only used for passing around data internally */\nconst _stackTrace = Symbol();\n/** @internal */\nexport interface NextRenderOptions {\n  timeout?: number;\n  [_stackTrace]?: string;\n}\n\n/** @internal */\nexport interface ProfiledComponent<Props, Snapshot>\n  extends React.FC<Props>,\n    ProfiledComponentFields<Props, Snapshot>,\n    ProfiledComponenOnlyFields<Props, Snapshot> {}\n\ninterface UpdateSnapshot<Snapshot> {\n  (newSnapshot: Snapshot): void;\n  (updateSnapshot: (lastSnapshot: Readonly<Snapshot>) => Snapshot): void;\n}\n\ninterface ProfiledComponenOnlyFields<Props, Snapshot> {\n  updateSnapshot: UpdateSnapshot<Snapshot>;\n}\ninterface ProfiledComponentFields<Props, Snapshot> {\n  /**\n   * An array of all renders that have happened so far.\n   * Errors thrown during component render will be captured here, too.\n   */\n  renders: Array<\n    Render<Snapshot> | { phase: \"snapshotError\"; count: number; error: unknown }\n  >;\n  /**\n   * Peeks the next render from the current iterator position, without advancing the iterator.\n   * If no render has happened yet, it will wait for the next render to happen.\n   * @throws {WaitForRenderTimeoutError} if no render happens within the timeout\n   */\n  peekRender(options?: NextRenderOptions): Promise<Render<Snapshot>>;\n  /**\n   * Iterates to the next render and returns it.\n   * If no render has happened yet, it will wait for the next render to happen.\n   * @throws {WaitForRenderTimeoutError} if no render happens within the timeout\n   */\n  takeRender(options?: NextRenderOptions): Promise<Render<Snapshot>>;\n  /**\n   * Returns the current render count.\n   */\n  currentRenderCount(): number;\n  /**\n   * Returns the current render.\n   * @throws {Error} if no render has happened yet\n   */\n  getCurrentRender(): Render<Snapshot>;\n  /**\n   * Iterates the renders until the render count is reached.\n   */\n  takeUntilRenderCount(\n    count: number,\n    optionsPerRender?: NextRenderOptions\n  ): Promise<void>;\n  /**\n   * Waits for the next render to happen.\n   * Does not advance the render iterator.\n   */\n  waitForNextRender(options?: NextRenderOptions): Promise<Render<Snapshot>>;\n}\n\n/** @internal */\nexport function profile<\n  Snapshot extends ValidSnapshot = void,\n  Props = Record<string, never>,\n>({\n  Component,\n  onRender,\n  snapshotDOM = false,\n  initialSnapshot,\n}: {\n  Component: React.ComponentType<Props>;\n  onRender?: (\n    info: BaseRender & {\n      snapshot: Snapshot;\n      updateSnapshot: UpdateSnapshot<Snapshot>;\n    }\n  ) => void;\n  snapshotDOM?: boolean;\n  initialSnapshot?: Snapshot;\n}) {\n  let currentRender: Render<Snapshot> | undefined;\n  let nextRender: Promise<Render<Snapshot>> | undefined;\n  let resolveNextRender: ((render: Render<Snapshot>) => void) | undefined;\n  let rejectNextRender: ((error: unknown) => void) | undefined;\n  const snapshotRef = { current: initialSnapshot };\n  const updateSnapshot: UpdateSnapshot<Snapshot> = (snap) => {\n    if (typeof snap === \"function\") {\n      if (!initialSnapshot) {\n        throw new Error(\n          \"Cannot use a function to update the snapshot if no initial snapshot was provided.\"\n        );\n      }\n      snapshotRef.current = snap(\n        typeof snapshotRef.current === \"object\"\n          ? // \"cheap best effort\" to prevent accidental mutation of the last snapshot\n            { ...snapshotRef.current! }\n          : snapshotRef.current!\n      );\n    } else {\n      snapshotRef.current = snap;\n    }\n  };\n  const profilerOnRender: React.ProfilerOnRenderCallback = (\n    id,\n    phase,\n    actualDuration,\n    baseDuration,\n    startTime,\n    commitTime\n  ) => {\n    const baseRender = {\n      id,\n      phase,\n      actualDuration,\n      baseDuration,\n      startTime,\n      commitTime,\n      count: Profiled.renders.length + 1,\n    };\n    try {\n      /*\n       * The `onRender` function could contain `expect` calls that throw\n       * `JestAssertionError`s - but we are still inside of React, where errors\n       * might be swallowed.\n       * So we record them and re-throw them in `takeRender`\n       * Additionally, we reject the `waitForNextRender` promise.\n       */\n      onRender?.({\n        ...baseRender,\n        updateSnapshot,\n        snapshot: snapshotRef.current!,\n      });\n\n      const snapshot = snapshotRef.current as Snapshot;\n      const domSnapshot = snapshotDOM\n        ? window.document.body.innerHTML\n        : undefined;\n      const render = new RenderInstance(baseRender, snapshot, domSnapshot);\n      // eslint-disable-next-line testing-library/render-result-naming-convention\n      currentRender = render;\n      Profiled.renders.push(render);\n      resolveNextRender?.(render);\n    } catch (error) {\n      Profiled.renders.push({\n        phase: \"snapshotError\",\n        count: Profiled.renders.length,\n        error,\n      });\n      rejectNextRender?.(error);\n    } finally {\n      nextRender = resolveNextRender = rejectNextRender = undefined;\n    }\n  };\n\n  let iteratorPosition = 0;\n  const Profiled: ProfiledComponent<Props, Snapshot> = Object.assign(\n    (props: Props) => (\n      <React.Profiler id=\"test\" onRender={profilerOnRender}>\n        <Component {...(props as any)} />\n      </React.Profiler>\n    ),\n    {\n      updateSnapshot,\n    } satisfies ProfiledComponenOnlyFields<Props, Snapshot>,\n    {\n      renders: new Array<\n        | Render<Snapshot>\n        | { phase: \"snapshotError\"; count: number; error: unknown }\n      >(),\n      currentRenderCount() {\n        return Profiled.renders.length;\n      },\n      async peekRender(options: NextRenderOptions = {}) {\n        if (iteratorPosition < Profiled.renders.length) {\n          const render = Profiled.renders[iteratorPosition];\n          if (render.phase === \"snapshotError\") {\n            throw render.error;\n          }\n          return render;\n        }\n        const render = Profiled.waitForNextRender({\n          [_stackTrace]: captureStackTrace(Profiled.peekRender),\n          ...options,\n        });\n        return render;\n      },\n      async takeRender(options: NextRenderOptions = {}) {\n        let error: { message?: string } | undefined = undefined;\n        try {\n          return await Profiled.peekRender({\n            [_stackTrace]: captureStackTrace(Profiled.takeRender),\n            ...options,\n          });\n        } catch (e) {\n          error = e;\n          throw e;\n        } finally {\n          if (!(error && error instanceof WaitForRenderTimeoutError)) {\n            iteratorPosition++;\n          }\n        }\n      },\n      getCurrentRender() {\n        if (!currentRender) {\n          throw new Error(\"Has not been rendered yet!\");\n        }\n        return currentRender;\n      },\n      async takeUntilRenderCount(\n        count: number,\n        optionsPerRender?: NextRenderOptions\n      ) {\n        while (Profiled.renders.length < count) {\n          await Profiled.takeRender(optionsPerRender);\n        }\n      },\n      waitForNextRender({\n        timeout = 1000,\n        // capture the stack trace here so its stack trace is as close to the calling code as possible\n        [_stackTrace]: stackTrace = captureStackTrace(\n          Profiled.waitForNextRender\n        ),\n      }: NextRenderOptions = {}) {\n        if (!nextRender) {\n          nextRender = Promise.race<Render<Snapshot>>([\n            new Promise<Render<Snapshot>>((resolve, reject) => {\n              resolveNextRender = resolve;\n              rejectNextRender = reject;\n            }),\n            new Promise<Render<Snapshot>>((_, reject) =>\n              setTimeout(\n                () =>\n                  reject(\n                    applyStackTrace(new WaitForRenderTimeoutError(), stackTrace)\n                  ),\n                timeout\n              )\n            ),\n          ]);\n        }\n        return nextRender;\n      },\n    } satisfies ProfiledComponentFields<Props, Snapshot>\n  );\n  return Profiled;\n}\n\n/** @internal */\nexport class WaitForRenderTimeoutError extends Error {\n  constructor() {\n    super(\"Exceeded timeout waiting for next render.\");\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\ntype StringReplaceRenderWithSnapshot<T extends string> =\n  T extends `${infer Pre}Render${infer Post}` ? `${Pre}Snapshot${Post}` : T;\n\ntype ResultReplaceRenderWithSnapshot<T> = T extends (\n  ...args: infer Args\n) => Render<infer Snapshot>\n  ? (...args: Args) => Snapshot\n  : T extends (...args: infer Args) => Promise<Render<infer Snapshot>>\n  ? (...args: Args) => Promise<Snapshot>\n  : T;\n\ntype ProfiledHookFields<Props, ReturnValue> = ProfiledComponentFields<\n  Props,\n  ReturnValue\n> extends infer PC\n  ? {\n      [K in keyof PC as StringReplaceRenderWithSnapshot<\n        K & string\n      >]: ResultReplaceRenderWithSnapshot<PC[K]>;\n    }\n  : never;\n\n/** @internal */\nexport interface ProfiledHook<Props, ReturnValue>\n  extends React.FC<Props>,\n    ProfiledHookFields<Props, ReturnValue> {\n  ProfiledComponent: ProfiledComponent<Props, ReturnValue>;\n}\n\n/** @internal */\nexport function profileHook<ReturnValue extends ValidSnapshot, Props>(\n  renderCallback: (props: Props) => ReturnValue\n): ProfiledHook<Props, ReturnValue> {\n  let returnValue: ReturnValue;\n  const Component = (props: Props) => {\n    ProfiledComponent.updateSnapshot(renderCallback(props));\n    return null;\n  };\n  const ProfiledComponent = profile<ReturnValue, Props>({\n    Component,\n    onRender: () => returnValue,\n  });\n  return Object.assign(\n    function ProfiledHook(props: Props) {\n      return <ProfiledComponent {...(props as any)} />;\n    },\n    {\n      ProfiledComponent,\n    },\n    {\n      renders: ProfiledComponent.renders,\n      currentSnapshotCount: ProfiledComponent.currentRenderCount,\n      async peekSnapshot(options) {\n        return (await ProfiledComponent.peekRender(options)).snapshot;\n      },\n      async takeSnapshot(options) {\n        return (await ProfiledComponent.takeRender(options)).snapshot;\n      },\n      getCurrentSnapshot() {\n        return ProfiledComponent.getCurrentRender().snapshot;\n      },\n      takeUntilSnapshotCount: ProfiledComponent.takeUntilRenderCount,\n      async waitForNextSnapshot(options) {\n        return (await ProfiledComponent.waitForNextRender(options)).snapshot;\n      },\n    } satisfies ProfiledHookFields<Props, ReturnValue>\n  );\n}\n"]}